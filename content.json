{"pages":[{"title":"about","text":"生而为人，我很抱歉作者: 白马文链接: http://blog.ixiaohuan.top来源: blog.ixiaohuan.top著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"friends","text":"这里编写您的友链声明，您可以陈述您的友链申请规则。 BMW 主题会自动渲染此篇markdown，并且在 http://localhost:4000/friends/ 展示给您！","link":"/friends/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Centos7安装数据库","text":"MySQL和Redis的安装以及简单配置 MySQL 下载源安装包 wget http://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm 安装源 yum -y install mysql57-community-release-el7-11.noarch.rpm 安装MySQL服务器 yum install mysql-community-server 启动并设置开机自启 systemctl start mysqld.service systemctl enable mysqld.service 初始化数据库密码 grep &quot;password&quot; /var/log/mysqld.log #修改默认密码策略 set global validate_password_policy=0; set global validate_password_length=1; set password = password('123456'); #设置密码 数据库授权 mysql&gt;GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION; Redis 下载安装包 wget http://download.redis.io/releases/redis-4.0.6.tar.gz 解压Redis mkidr /usr/local/redis tar -zxvf redis-4.0.6.tar.gz -C /usr/local/redis/ 安装gcc依赖 yum install gcc 编译安装 cd /usr/local/redis/redis-4.0.6 make MALLOC=libc cd src &amp;&amp; make install","link":"/2019/04/20/Centos7安装数据库/"},{"title":"Pig简单了解","text":"基于W3School的Pig学习笔记 定义Apache Pig是MapReduce的一个抽象，是一个工具/平台，用于分析较大的数据集，并将它们表示为数据流。 可以使用Pig在Hadoop中执行所有的数据处理的操作 下载地址：[ http://mirrors.shu.edu.cn/apache/pig/pig-0.17.0/ ] 先决条件：在运行在Apache Pig之前，必须在系统上安装h好Hadooph和Java 安装123456789101112131415# 创建pig存放目录mkdir /opt/pig# 解压pigtar xvf tar xvf pig-0.17.0.tar.gzmv pig-0.17.0/* /opt/pig# 添加环境变量export PIG_HOME=/opt/pigexport PIG_CLASSPATH=$PIG_HOME/confexport PATH=$PIG_HOME/bin:$PATH# 查看是否配置成功pig -version Pig的执行模式和机制模式 Local模式(pig -x local) 在此模式下，所有文件都从本地主机和本地文件系统加载，通常用于测试。 MapReduce模式(pig -x mapreduce) 使用Pig加载或处理Hadoop文件系统中存在的数据的地方。在这种模式下， 每当执行Pig语句来处理数据时，会在后端调用一个MapReduce作业。 执行机制通过三种方式执行，即交互模式 交互模式（Grunt shell） 在此shell中，可以输入Pig Latin语句并获取输出（使用Dump运算符） 批处理模式（脚本） 可以将Pig Latin脚本写入具有.pig扩展名的单个文件中，以批处理模式运行 嵌入式模式（UDF） Pig允许在Java等编程语言中定义自己的函数，并在脚本中运行 Pig Grunt Shell示例：sh ls调用Linux shell 的ls命令 示例： fs -ls调用HDFS的ls命令 示例： exec /sample_script.pig从Grunt shell执行Pig脚本 示例： run /sample_script.pig从Grunt shell运行Pig脚本 exec和run命令之间的区别是，如果使用run，则脚本中的语句在historym命令中可用 Pig LatinPig Latin适用于使用Pig分析Hadoop中数据的语言 数据模型Pig的数据模型是完全嵌套的。 包是元组的集合 元组是有序的字段集 字段是一段数据 类型结构运算符() -&gt; 元组构造函数运算符，用于构建元组 {} -&gt; 包构造函数运算符，用于构造包 -&gt; 示例:{（Raju,30）,（Mohammad,45）} [] -&gt; 映射构造函数运算符，用于构造一个映射 -&gt; 示例：[name＃Raja,age＃30] 关系运算符 运算符 描述 加载和存储 LOAD 将数据从文件系统(local/HDFS)加载到关系中 STORE 将数据从文件系统(local/HDFS)存储到关系中 过滤 FILTER 从关系中删除不需要的行 DISTINCT 从关系中删除重复行 FOREACH, GENERATE 基于数据列生成数据转换 STREAM 使用外部程序转换关系 分组和连接 JOIN 连接两个或多个关系 COGROUP 将数据分组为两个或多个关系 GROUP 在单个关系中对数据进行分组 CROSS 创建两个或多个关系的向量积 排序 ORDER 基于一个或多个字段（升序或降序）排列关系 LIMIT 从关系中获取有限数量的元组 诊断运算符 DUMP 在控制台打印关系的内容 LOAD 运算符语法： load语句由两部分组成，用“=”运算符分隔。 左侧是想要存储数据的关系的名称 右侧是需要定义如何存储数据 Relation_name = LOAD 'Input file path' USING function as schema; releation_name：必须要提到要存储的关系 Input file path：必须提到存储文件的HDFS目录(MapReduce模式) function：必须从Pig提供的一组加载函数中选择一个函数(BigStorage, JsonLoader, PigStorage, TextLoader) schema：必须定义数据的模式 PigStorage() 函数，将数据加载并存储为结构化文本文件。它采用分隔符，使用元组的每个实体作为参数分隔。默认情况下，它以“\\t”作为参数。 STORE 存储数据语法：STORE Relation_name INTO 'required_directory_path' [USING function]; Group运算符用于在一个或多个关系中对数据进行分组，它收集具有相同key的数据 语法：Group_data = GROUP Relation_name BY age; Foreach运算符用于基于列数据生成指定的数据转换 语法：Relation_name2 = FOREACH Relation_name1 GENRATE (required data);","link":"/2019/04/20/Pig简单了解/"},{"title":"Python创建单例模式的三种方法","text":"简单的列举了单例的创建方式 方法一：使用装饰器装饰器维护一个字典对象instances，缓存了所有的单例类，只要单例类不存在则创建，已经创建直接返回该实例对象。def singleton(cls): instances = {} def wrapper(*args, **kwargs): if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return wrapper @singletonclass Foo(object): pass foo1 = Foo()foo2 = Foo() print(id(foo1), id(foo2)) 方法二：使用基类new是真正创建实例对象的方法，所以重写基类的new方法，以此来保证创建对象的时候只生成一个实例。class Singleton(object): def new(cls, args, **kwargs): if not hasattr(cls, ‘_instance’): cls._instance = super(Singleton, cls).new(cls, args, **kwargs) return cls._instance class Foo(Singleton): pass foo1 = Foo()foo2 = Foo() print(foo1 is foo2) 方法三：使用元类元类是用于创建类对象的类， 类对象创建实例对象时一定会调用call方法，因此在调用call时候保证始终只创建一个实例即可，type是Python中的一个元类。class Singleton(type): def call(cls, args, **kwargs): if not hasattr(cls, ‘_instance’): cls._instance = super(Singleton, cls).call(args, **kwargs) return cls._instance class Foo(object): metaclass = Singleton foo1 = Foo()foo2 = Foo() print(foo1 is foo2)","link":"/2019/04/20/Python创建单例模式的三种方法/"},{"title":"Virtualenv虚拟环境","text":"关于Python虚拟环境的创建 virtualenv下载virtualenvinstall virualenv```123### 创建虚拟环境```virualenv + 环境名 -p + python解释器路径可以指定版本创建 开启和退出环境 进入到Scripts目录中使用activate开启 使用deactivate退出环境 virtualenvwrapper是一个用于管理虚拟环境的，也可以直接下载 (里面包含virtualenv) 下载virtualwrapperinstall virtualenvwrapper-win```123### 创建虚拟环境```mkvirtualenv 环境名 当虚拟环境创建完成后默认自动进入到虚拟环境 切换虚拟环境或进入到虚拟环境workon + 虚拟环境名 列出、删除、退出或进入到虚拟环境所在目录lsvirtualenv – 列出虚拟环境 rmvirtualenv – 删除虚拟环境 deactivate – 退出当前虚拟环境 cdvirtualenv – 进入到虚拟环境所在目录 修改虚拟环境创建时所在目录需要在环境变量中添加WORKON_HOME=xxx ==如果需要在创建环境时指定python版本可以添加–python=路径 这个参数==","link":"/2019/04/20/Virtualenv虚拟环境/"},{"title":"XML & Tomcat","text":"关于XML和Tomcat的学习笔记 XML &amp; Tomcat 被设计用来传输和存储数据 查看XML文件XMl文件中包含了许多的元素，XML格式的信息和其它标记的基本单元，以及各种各样的数据。 在所有的主流的浏览器中，均能够查看原始的XML文件 什么是XML 指可扩展标记语言（EXtendsible Markup Language） 是一种很像HTML的标记语言 设计宗旨是传输数据，而不是显示数据 标签没有被预定义，需要自行定义 被设计为具有自我描述性 和HTML的差异 XML是被设计用来传输和存储数据，其焦点是数据的内容 HTML被设计用来显示数据，其焦点是数据的外观 XML用于传输数据，而HTML用于格式化并显示数据 定义XML 文档声明version：解析这个xml的时候，使用什么版本的解析器解析encoding：解析xml中的文字的时候，使用什么编码来翻译 standalone：no - 该文档会依赖关联其它文档 yes - 这是一个独立的文档&lt;?xml version=”1.0” encoding=”UTF-8” standalone=”no”?&gt; 使用CSS来格式化XML文档 &lt;?xml-stylesheet type=”text/css” href=”cd_catalog.css”?&gt;使用CSS格式化XML不是常用的方法 使用XSLT显示XML 通过使用XSLT，可以把XMl文档转换HTML格式 XSLT是首选的XML样式表语言 (eXtensible Stylesheet Language Transformations) XML命名规则 名称可以包含字母、数字以及其它的字符 名称不能以数字或者标点符号开始 名称不能以字母xml（或者XML、Xml等等）开始 名称不能包含空格 XML DTD（Document Type Definition）文档类型定义 拥有正确语法的XMl被称为“形式良好”的XMl 文档必须有一个根元素 元素都必须有一个关闭标签 标签对大小写敏感 元素必须被正确的嵌套 属性值必须加双引号 DTD的作用 DTD是一种保证XML文档格式正确的有效方法，可以通过比较XML文档和DTD文件来看文档是否符合规范，元素和标签使用是否正确 XML文件提供应用程序一个数据交换的格式，DTD正是让XML能够成为数据交换的标准。 DTD文件是一个ASCII的文本文件，后缀名为.dtd 通过引入的方式：12345文档类型 根标签名字 网络上的dtd dtd的路径&lt;!DOCTYPE stus PUBLIC &quot;//UNKNOWN/&quot; &quot;unknown.dtd&quot;&gt;本地的为&lt;!DOCTYPE stus SYSTEM &quot;stus.dtd&quot;&gt; 直接在XML里面嵌入DTD的约束规则：1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE stus [ &lt;!ELEMENT stus (stu)&gt; &lt;!ELEMENT stu (name,age,address)&gt; &lt;!ELEMENT name (#PCDATA)&gt; &lt;!ELEMENT age (#PCDATA)&gt; &lt;!ELEMENT address (#PCDATA)&gt;]&gt;&lt;stus&gt; &lt;stu&gt; &lt;name&gt;李四&lt;/name&gt; &lt;age&gt;12&lt;/age&gt; &lt;address&gt;武汉&lt;/address&gt; &lt;/stu&gt;&lt;/stus&gt; XML Schema约束文档12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- xmlns-&gt;xml namespace 命名空间目标名称空间，下面的那些元素都与这个命名空间绑定上targetNamespace=\"http://www.example.org/teacher\"元素的格式化情况elementFormDefault=\"qualified\"&gt; --&gt;&lt;schema xmlns=\"http://www.w3.org/2001/XMLSchema\" targetNamespace=\"http://www.example.org/teacher\" xmlns:tns=\"http://www.example.org/teacher\" elementFormDefault=\"qualified\"&gt; &lt;element name=\"teachers\"&gt; &lt;complexType&gt; &lt;sequence maxOccurs=\"unbounded\"&gt; &lt;!-- 这是一个复杂元素 --&gt; &lt;element name=\"teacher\"&gt; &lt;!-- 这是用于声明teacher元素是复杂元素 --&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;!-- 以下两个是简单元素 --&gt; &lt;element name=\"name\" type=\"string\"&gt;&lt;/element&gt; &lt;element name=\"age\" type=\"int\"&gt;&lt;/element&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt;&lt;/schema&gt; 实例文档123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- xmlns:xsi 必须是这样的写法，也就是这个值固定了 xmlns 这里是命名空间，也固定了，写的是schema里面的顶部目标命名空间 xsi:schemaLocation 有两段，前面是命名空间，也就是目标空间的值，后面是约束文档的路径 --&gt;&lt;teachers xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www.w3.org/2001/XMLSchema\" xsi:schemaLocation=\"http://www.w3.org/2001/XMLSchema teacher.xsd\"&gt; &lt;teacher&gt; &lt;name&gt;z&lt;/name&gt; &lt;age&gt;12&lt;/age&gt; &lt;/teacher&gt; &lt;teacher&gt; &lt;name&gt;z&lt;/name&gt; &lt;age&gt;12&lt;/age&gt; &lt;/teacher&gt;&lt;/teachers&gt; 命名空间的作用一个xml如果想指定它的约束规则，假设使用的是DTD，那么这个xml只能指定一个DTD 但是如果一个xml的约束是定义在schema里面，并且是多个schema，那么是可以的。 简单来说：一个xml可以引用多个schema约束，但是只能引用一个DTD约束。 名称空间的作用就是在写元素的时候，可以指定该元素使用的是哪一套约束规则。 默认情况下，如果只有一套规则，那么都可以这么写。 123&lt;name&gt;zhangsan&lt;/name&gt;&lt;aa:name&gt;&lt;/name&gt;&lt;bb:name&gt;&lt;/name&gt; XMl解析方式 DOM：document object model 把整个xml全部读到内从当中，形成树状结构。 整个文档称之为document对象 属性对应Attribute对象 所有的元素节点对应Element对象 文本称之为Text对象 以上所有对象都可称之为Node节点 SAX：Simple API for Xml 基于事件驱动 不可以进行增删，只能查询 Dom4j 基本用法element.element(“stu”); 返回该元素下的第一个stu元素element.elements(); 返回该元素下的所有子元素 创建SaxReader对象 指定解析的xml 获取根元素 根据根元素获取子元素或者下面的子孙元素 1234567891011121314151617181920212223try { // 1. 创建sax读取对象 SAXReader reader = new SAXReader(); // 2. 指定解析的xml文件 Document document = reader.read(new File(\"src/xml/stus.xml\")); // 3. 得到元素 Element rootElement = document.getRootElement(); String name = rootElement.element(\"stu\").element(\"name\").getStringValue(); //System.out.println(name); // 获取根元素下的所有元素 List&lt;Element&gt; elements = rootElement.elements(); for (Element element : elements) { String value1 = element.getStringValue(); String value2 = element.element(\"name\").getText(); System.out.println(value2); } } catch (Exception e) { // TODO: handle exception e.printStackTrace(); } Dom4j的Xpath使用 添加jar包依赖 jaxen-1.1-beta-6.jar 在查找指定节点的时候，根据Xpath语法规则来查找 后续的代码与以前的解析一样 1234567891011// 要想使用Xpath，还得添加支持的jar:jaxen// 获取的是第一个，只返回一个Element nameElement = (Element) rootElement.selectSingleNode(\"//name\");System.out.println(nameElement.getName());// 获取文档里面的所有name元素List&lt;Element&gt; list = rootElement.selectNodes(\"//name\");for (Element element : list) { System.out.println(element.getText());} Tomcat目录bin 包含了一些jar，bat文件 startup.bat conf tomcat的配置 server.xml web.xml lib tomcat运行所需的jar文件 logs 运行的日志文件 temp 临时文件 webapps 发布到tomcat服务器上的项目 work jsp翻译成class文件存放地 配置虚拟路径 在conf/server.xml 找到Host元素节点 加入以下内容 OR 在tomcat/conf/catalina/localhost/ 文件夹下新建一个xml文件，名字自定义 在这个文件里面写入 &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; 访问：http://localhost:8080/person/xml名字即可","link":"/2019/03/28/XML&Tomcat/"},{"title":"Spring的学习（一）","text":"Spring的一些关键字概念及配置 Spring概述什么是SpringSpring是一个开源框架，Spring是于2003年兴起的一个轻量级的Java开发框架，由Rod Johnson创建。 简单来说，Spring是一个分层的JavaSE/EE full-stack(一站式)轻量级开原框架 Spring叫做SE/EE开发的一站式框架 一站式框架：有EE开发的每一层解决方案 WEB层：SpringMVC Service层：Spring的Bean管理，Spring声明式事务 DAO层：Spring的JDBC模板，Spring的ORM模块 特点 方便解耦，简化开发 通过Spring提供的IoC容器，我们可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。有了Spring，用户不必再为单实例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。 AOP编程的支持 通过Spring提供的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。 声明式事务的支持 在Spring中，我们可以从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。 方便程序的测试 可以用非容器依赖的编程方式进行几乎所有的测试工作，在Spring里，测试不再是昂贵的操作，而是随手可做的事情。例如：Spring对Junit4支持，可以通过注解方便的测试Spring程序。 方便集成各种优秀框架 Spring不排斥各种优秀的开源框架，相反，Spring可以降低各种框架的使用难度，Spring提供了对各种优秀框架（如Struts,Hibernate、Hessian、Quartz）等的直接支持。 6.降低Java EE API的使用难度 Spring对很多难用的Java EE API（如JDBC，JavaMail，远程调用等）提供了一个薄薄的封装层，通过Spring的简易封装，这些Java EE API的使用难度大为降低。 Java 源码是经典学习范例 Spring的源码设计精妙、结构清晰、匠心独运，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。Spring框架源码无疑是Java技术的最佳实践范例。如果想在短时间内迅速提高自己的Java技术水平和应用开发水平，学习和研究Spring源码将会使你收到意想不到的效果。 SpringIOC(XML)什么是IOC控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。 IOC：Inversion of Control(控制反转) 控制反转：将对象的创建权反转给（交给）Spring。 123456789101112131415&lt;!-- applicationContext.xml --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"foo\" class=\"x.y.Foo\"&gt; &lt;meta key=\"cacheName\" value=\"foo\"/&gt; &lt;property name=\"name\" value=\"Rick\"/&gt; &lt;/bean&gt;&lt;/beans&gt; Spring方式的调用1234567public void demo02(){ // 创建Spring的工厂 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); Object userDao = applicationContext.getBean(\"userDao\"); userDao.save();} IOC和DI IOC：控制反转，将对象的创建权反转给了Spring DI：依赖注入：前提必须要有IOC的环境（对象已经交给Spring），Spring在管理类的时候会将类的依赖的属性注入（设置）进来 Spring的工厂类结构图 BeanFactory：老版本的工厂类 调用getBean的时候，才会生成类的实例 ApplicationContext：新版本的工厂类 加载配置文件的时候，就会将Spring管理的类都实例化 有两个实现类 ClassPathXmlApplicationContext：加载类路径下的配置文件 FileSystemXmlApplicationContext ：加载文件系统下的配置文件 Spring的Bean管理标签的id和name的配置 id：使用了约束的唯一约束，里面不能出现特殊字符 name：没有使用约束中的唯一约束 Bean生命周期的配置1234&lt;!-- applicationContext.xml --&gt;&lt;bean id=\"customeDao\" class=\"com.xx.spring.demo02.CustomeDaoImpl\" init-method=\"setup\" destroy-method=\"destroy\"&gt;&lt;/bean&gt; init-method：Bean被初始化的时候执行的方法 destroy-method：Bean被销毁的时候执行的方法（默认Bean是单例模式，工厂关闭） Bean的作用范围的配置 scope：Bean的作用范围 singleton：默认，Spring会采用单例模式创建对象 prototype：多例模式（在Struts2和Spring整合一定会用到） request：应用在web项目中，Spring创建这个类以后，会将这个类存入到request范围中 session：应用在web项目中，Spring创建这个类以后，会将这个类存入到session范围中 globalsession：必须在porlet环境下使用（在一个地方存入了数据以后，在子系统中就不需要进行登陆） 1234&lt;!-- applicationContext.xml --&gt;&lt;bean id=\"customeDao\" class=\"com.xx.spring.demo02.CustomeDaoImpl\" scope=\"xx\"&gt;&lt;/bean&gt; Spring属性注入构造方法的属性注入123456789101112131415161718192021222324// Car.jarpublic Class Car { private String name; private Double price; public Car(String name, Double price) { super(); this.name = name; this.price = price; }}// SpringDemo01public class SpringDemo01 { public void demo01() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); Car car = applicationContext.getBean(\"car\"); System.out.println(car); }} 1234567&lt;!-- applicationContext.xml --&gt;&lt;bean id=\"car\" class=\"com.xx.spring.demo02.Carl\"&gt; &lt;constructor-arg name=\"name\" value=\"可乐\" /&gt; &lt;constructor-arg name=\"price\" value=\"2.5\"&gt;&lt;/bean&gt; Set方法的属性注入1234567// 和构造方法差不多，配置文件不一样&lt;bean id=\"foo\" class=\"x.y.Foo\"&gt; &lt;!-- value：用来设置普通类型的值 ref：设置其他类型的id或name --&gt; &lt;property name=\"name\" value=\"可乐\"/&gt; &lt;property name=\"price\" value=\"2.5\"/&gt; &lt;property name=\"car2\" ref=\"car2\"/&gt;&lt;/bean&gt; P 名称空间的属性注入 写法 普通属性：p：属性名=“值” 对象属性：p：属性名-ref=”值“123xmlns:p=\"http://www.springframework.org/schema/p\"&lt;bean id=\"foo\" class=\"x.y.Foo\" p:name=\"可乐\" p:price=\"2.5\" &gt;&lt;/bean&gt; SpEL的属性注入 SpEL：Spring Expression Language，Spring的表达语言 集合类型的属性注入1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- Spring的集合属性的注入============================ --&gt; &lt;!-- 注入数组类型 --&gt; &lt;bean id=\"collectionBean\" class=\"com.itheima.spring.demo5.CollectionBean\"&gt; &lt;!-- 数组类型 --&gt; &lt;property name=\"arrs\"&gt; &lt;list&gt; &lt;value&gt;王东&lt;/value&gt; &lt;value&gt;赵洪&lt;/value&gt; &lt;value&gt;李冠希&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 注入list集合 --&gt; &lt;property name=\"list\"&gt; &lt;list&gt; &lt;value&gt;李兵&lt;/value&gt; &lt;value&gt;赵如何&lt;/value&gt; &lt;value&gt;邓凤&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 注入set集合 --&gt; &lt;property name=\"set\"&gt; &lt;set&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- 注入Map集合 --&gt; &lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"aaa\" value=\"111\"/&gt; &lt;entry key=\"bbb\" value=\"222\"/&gt; &lt;entry key=\"ccc\" value=\"333\"/&gt; &lt;/map&gt; &lt;/property&gt; SpringIOC注解开启Spring的组件扫描1&lt;context:component-scan base-package=\"com.itheima.spring.demo1\" /&gt; 在类上添加注解1234567@component(\"userDao\")public class UserDaoImpl implements UserDao { @Override public void save(){ System.out.pringln(\"DAO中保存的方法执行了...\"); }} Component：组件 修饰一个类，将这个类交给Spring管理 这个注解有三个衍射注解 @Controller：web层 @Service：service层 @@Repository：dao层 属性注入的注解 普通属性 @Value：设置普通属性的值 对象类型属性 @Autowired：设置对象类型属性的值，是按照类型完成属性注入 如果想按照名称完成属性注入，必须让@Autowired注解和@Qualifier一起使用 @Resource：完成对象类型的属性注入，按照名称完成属性注入。 Spring的AOP开发(XML)什么是AOP在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 AOP相关术语 Joinpoint：连接点，所谓连接点是指那些被拦截的点。 Pointcut：切入点，所谓切入点是指要对哪些Joinpoint进行拦截的定义 Advice：通知、增强。所谓通知是指拦截到Joinpoint之后所要做的事情就是通知，通知分为前置通知、后置通知、异常通知、最终通知、环绕通知 Introduction：引介。引介是一种特殊的通知，在不修改类代码的情况下，Introduction可以在运行期间为类动态的添加一些方法或Field。 Target：目标对象。代理的目标对象 Weaving：织入，是指把增强应用到目标对象来创建新的代理对象的过程。 Proxy：代理，一个类被AOC织入增强后，就产生一个结果代理类 Aspect：切面，是切入点和通知（引介）的结合。 12345678910111213141516&lt;!-- 配置目标对象；被增强的对象 --&gt;&lt;bean id=\"productDao\" class=\"com.itheima.spring.demo3.ProductDaoImpl\" /&gt;&lt;!-- 将切面类交给Spring管理 --&gt;&lt;bean id=\"myAspect\" class=\"com.itheima.spring.demo3.MyAspectXMl\" /&gt;&lt;!-- 通过AOP的配置完成对目标类产生代理 --&gt;&lt;aop:config&gt; &lt;!-- 表达式配置哪些类的哪些方法需要进行增强 --&gt; &lt;aop:pointcut expression=\"execution(* com.itheima.spring.demo3.ProductDaoImpl.save(..))\" id=\"pointcut1\" /&gt; &lt;!-- 配置切面 --&gt; &lt;aop:aspect&gt; &lt;aop:before method=\"checkPri\" pointcut-ref=\"pointcut1\" /&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 1234567891011121314151617181920212223// SpringDemo03.java@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class SpringDemo03 { @Resource(name=\"productDao\") private ProductDao productDao; @Test public void demo1(){ productDao.save(); productDao.update(); }}// MyAspectXML.java 切面类public class MyAspectXMl { public void checkPri() { System.out.pringln(\"权限校验=====\"); }} 通知类型 前置通知：在目标方法执行之前执行（获得切入点信息） 后置通知：在目标方法执行之后执行（获得方法的返回值） 环绕通知：在目标方法执行前和执行后执行（可以阻止目标方法的执行） 异常抛出通知：在目标方法执行出现异常的时候执行 最终通知：无论目标方法是否出现异常最终通知都会执行 12345678910&lt;!-- 前置通知 --&gt;&lt;aop:before method=\"checkPri\" pointcut-ref=\"pointcut1\" /&gt;&lt;!-- 后置通知 --&gt;&lt;aop:after-returning method=\"writeLog\" pointcut-ref=\"pointcut2\" returning=\"result\" /&gt;&lt;!-- 环绕通知 ---&gt;&lt;aop:around method=\"around\" pointcut-ref=\"pointcut3\" /&gt;&lt;!-- 异常抛出通知 --&gt;&lt;aop:after-throwing method=\"afterThrowing\" pointcut-ref=\"pointcut4\" throwing=\"ex\" /&gt;&lt;!-- 最终通知 --&gt;&lt;aop:after method=\"after\" pointcut-ref=\"pointcut4\" /&gt; 1234567891011121314151617181920212223242526272829public class MyAspectXML { // 前置通知 public void checkPri(JoinPoint joinPoint) { System.out.println(\"权限校验===\" + joinPoint); } // 后置通知 public void writeLog(Object result) { System.out.println(\"日志记录===\" + result); } // 性能监控，环绕通知 public Object around(ProceedingJoinPoint joinPoint) { System.out.println(\"环绕前通知===\"); Object obj = joinPoint.proceed(); System.out.println(\"环绕后通知===\"); return obj; } // 异常抛出通知 public void afterThrowing(Throwable ex) { System.out.println(\"异常抛出通知===\" + ex.getMessage()); } // 最终通知，相当于finally代码块的内容 public void after() { System.out.println(\"最终通知===\"); }} 切入点表达式语法 基于execution的函数完成的 语法 [访问修饰符] 方法返回值 包名.类名.方法名(参数) public void com.itheima.spring.CustomerDao.save(..)Spring的AOP注解 12&lt;!-- 在配置文件中开启注解AOP --&gt;&lt;aop:aspectj-autoproxy /&gt; 1234567@Aspectpublic class MyAspectAnno { @Before(value=\"execution(* com.itheima.spring.demo1.OrderDao.save(..)\") public void before() { System.out.println(\"前置增强===\"); }} 注解的AOP通知类型 @Before：前置通知 @AfterReturning：后置通知 @Around：环绕通知 @AfterThrowing：异常抛出通知 @After：最终通知 12345678// 切入点注解@Pointcut(value=\"execution(* com.itheima.spring.demo1.OrderDao.find(..))\")private void pointcut1(){}@After(value=\"MyAspectAnno.pointcut1()\") public void before() { System.out.println(\"前置增强===\"); } Spring的事务管理 事务：逻辑上的一组操作，组成这组操作的各个单元，要么全部成功，要么全部失败。 事务的特性： 原子性：事务不可分割 一致性：事务执行前后数据完整性保持一致 隔离性：一个事务的执行不应该受到其他事务的干扰 持久性：一旦事务结束，数据就持久化到数据库 不考虑隔离性引发安全性问题 读问题 脏读：一个事务读到另一个事务未提交的数据 不可重复读：一个事务读到另一个事务已经提交的update的数据，导致一个事务中多次查询结果不一致 虚读、幻读：一个事务读到另一个事务已经提交的insert的数据，导致一个事务中多次查询结果不一致 写问题 丢失更新 解决读问题 设置事务的隔离级别 Read uncommitted：未提交读，任何读问题解决不了。 Read committed：已提交到，解决脏读，但是不可重复读和虚读有可能发生 Repeatable read：重复读，解决脏读和不可重复读，但是虚读有可能发生 Serializable：解决所有读问题。 Spring的事务管理API PlatformTransactionManager：平台事务管理器 接口，是Spring用于管理事务的真正的对象 DataSourceTransactionManager：底层使用JDBC管理事务 HibernateTransactionManager：底层使用Hibernate管理事务 TransactionDefinition：事务定义信息 事务定义：用于定义事务的相关的信息，隔离级别、超时信息、传播行为、是否只读。 TransactionStatus：事务的状态 事务状态：用于记录在事务管理过程中，事务的状态的对象。 事务管理的API关系Spring进行事务管理的时候，首先平台事务管理器根据事务定义信息进行事务的管理，在事务管理过程中，产生各种状态，将这些状态的信息记录到事务状态的对象中。 Spring事务的传播行为用途：如果遇到了特别复杂的业务逻辑，有可能出现业务层之间的方法相互调用。事务的传播行为主要用来解决业务层方法相互调用的问题。 Spring中提供了七种事务的传播行为 保证同一个事务中 PROPAGATION_REQUIRED：支持当前事务，如果不存在，就新建一个（默认） PROPAGATION_SUPPORTS：支持当前事务，如果不存在，就不使用事务 PROPAGATION_MANDATORY：支持当前事务，如果不存在，抛出异常 保证没有在同一个事务中 PROPAGATION_REQUIRES_NEW：如果有事务存在，挂起当前事务，创建一个新的事务 PROPAGATION_NEVER：以非事务方式运行，如果有事务存在，挂起当前事务 PROPAGATION_NESTED：如果当前事务存在，则嵌套事务执行 编程式事务123456789101112&lt;!-- 配置平台事务管理器 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;&lt;/bean&gt;&lt;!-- 配置事务管理的模板 --&gt;&lt;bean id=\"transactionTemplate\" class=\"org.springframework.transaction.support.TransactionTemplate\"&gt; &lt;property name=\"transactionManager\" ref=\"transactionManager\" /&gt;&lt;/bean&gt;&lt;!-- 注入事务管理的模板 --&gt;&lt;property name=\"trsactionTemplate\" ref=\"transactionTemplate\" /&gt; 12345678910111213141516// 注入事务管理的模板private TransactionTemplate trsactionTemplate;public void setTrsactionTemplate(TransactionTemplate trsactionTemplate) { this.trsactionTemplate = trsactionTemplate;}public void transfer(final String from, final String to, final Double money) { trsactionTemplate.execute(new TransactionCallbackWithoutResult() { @Override protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) { accountDao.outMoney(from, money); // int d = 1/0; accountDa.inMoney(to, money); } });} 声明式事务管理XML方式的声明式事务管理1234567891011121314151617&lt;!-- 配置事务管理器 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=dataSource\"\"/&gt;&lt;/bean&gt;&lt;!-- 配置事务的增强 --&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"save*\" propagation=\"REQUIRED\" /&gt; &lt;/tx:attributes&gt;&lt;tx:advice&gt;&lt;!-- AOP的配置 --&gt;&lt;aop:config&gt; &lt;aop:pointcut expression=\"execution(* com.itheima.tx.demo2.AccountServiceImpl.*(..))\" id=\"pointcut1\" /&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pointcut1\" /&gt;&lt;/aop:config&gt; 注解方式的声明式事务管理1234567&lt;!-- 配置事务管理器 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=dataSource\"\"/&gt;&lt;/bean&gt;&lt;!-- 开启注解事务 --&gt;&lt;tx:annotation-driven transaction-manager=\"transactionManager\" /&gt; 123// 在业务层上添加注解@Transactionalpublic class AccountServiceImpl implements AccountService{} JdbcTemplate使用JDBC的模板：保存数据123456789101112131415public class JdbcDemo1 { @Test public void demo1() { // 创建连接池 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\"); dataSource.setUrl(\"jdbc:mysql:///spring4_day03\"); dataSource.setUsername(\"root\"); dataSource.setPassword(\"abc\"); // 创建jdbc模板 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); jdbcTemplate.update(\"insert into account values (null,?,?)\", \"xx\", 1000d); }} 将连接池和模板交给Spring管理1234567891011121314&lt;!-- 配置Spring的内置连接池 --&gt;&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;!-- 属性注入 --&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///spring4_day03\" /&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"abc\" /&gt;&lt;/bean&gt;&lt;!-- 配置Spring的JDBC的模板 --&gt;&lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\" /&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;&lt;/bean&gt; 123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class JdbcDemo2 { @Resource(name=\"jdbcTemplate\") private JdbcTemplate jdbcTemplate; @Test public void demo2() { jdbcTemplate.update(\"insert into account values (null, ?, ?)\", \"xx\", 1000d); }} 使用开源的数据库连接池DBCP的使用1234567&lt;!-- 配置DBCP连接池 --&gt;&lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///spring4_day03\" /&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"abc\" /&gt;&lt;/bean&gt; C3P0的使用1234567&lt;!-- 配置C3P0连接池 --&gt;&lt;bean id=\"dataSource\" class=\"org.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql:///spring4_day03\" /&gt; &lt;property name=\"user\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"abc\" /&gt;&lt;/bean&gt; 引入外部属性文件12345678910111213141516171819# jdbc.propertiesjdbc.driverClass=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql:///spring4_day03jdbc.username=rootjdbc.password=abc&lt;!-- 引入属性文件 --&gt;&lt;!-- 第一种方式通过一个bean标签引入（很少使用） --&gt;&lt;bean class=\"org.springframework.beans.factory.config.PropertyPlanceholderConfigurer\"&gt; &lt;property name=\"location\" value=\"classpath:jdbc.properties\" /&gt;&lt;/bean&gt;&lt;!-- 第二种方式通过context的标签引入 --&gt;&lt;context:property-placeholder localtion=\"classpath:jdbc.properties\" /&gt;&lt;!-- 配置连接池的时候 --&gt;&lt;property name=\"driverClass\" value=\"${jdbc.driverClass}\" /&gt;&lt;property name=\"jdbcUrl\" value=\"${jdbc.url}\" /&gt; SSH整合 无障碍整合 创建Web项目，引入jar包 Struts2的jar包 struts-2.3.24\\apps\\struts2-blank\\WEB-INF\\lib*.jar asm-3.3.jar asm-commons-3.3.jar asm-tree-3.3.jar commons-fileupload-1.3.1.jar commons-io-2.2.jar commons-lang3-3.2.jar freemarker-2.3.22.jar javassist-3.11.0.GA.jar log4j-api-2.2.jar log4j-core-2.2.jar ognl-3.0.6.jar struts2-core-2.3.24.jar xwork-core-2.3.24.jar struts2-convention-plugin-2.3.24.jar —-Struts2的注解开发包 struts2-json-plugin-2.3.24.jar —-Struts2的整合AJAX的开发包 struts2-spring-plugin-2.3.24.jar —-Struts2的整合Spring的开发包 Hibernate的jar包 Hibermate的开发必须包（Struts2和Hibernate都引入了一个相同的jar包，javassist，需要删除一个） hibernate-release-5.0.7.Final\\lib\\required*.jar antlr-2.7.7.jar dom4j-1.6.1.jar geronimo-jta_1.1_spec-1.1.1jar hibernate-commons-annotations-5.0 hibernate-core-5.0.7.Final.jar hibernate-jpa-2.1-api-1.0.0.Final.jar jandex-2.0.0.Final.jar javassist-3.18.1-GA.jar jboss-logging-3.3.0.Final.jar MYSQL驱动 日志记录 log4j-1.2.16.jar slf4j-api-1.6.1.jar slf4j-log4j12-1.7.2.jar Spring的jar包 IOC的开发 com.springsource.org.apache.commons.loggin-1.1.1.jar com.springsource.org.apache.log4j-1.2.15.jar spring-beans-4.2.4.RELEASE.jar spring-context-4.2.4.RELEASE.jar spring-core-4.2.4.RELEASE.jar spring-expression-4.2.4.RELEASE.jar AOP的开发 com.springsource.org.aopalliance-1.0.0.jar com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar spring-aop-4.2.4.RELEASE.jar spring-aspects-4.2.4.RELEASE.jar JDBC模板的开发 spring-jdbc-4.2.4.RELEASE.jar spring-tx-4.2.4.RELEASE.jar （如果只用事务管理只用这个） 整合web项目的开发 spring-web-4.2.4.RELEASE.jar 整合单元测试的开发 spring-test-4.2.4.RELEASE.jar 整合hibernate的开发 spring-orm-4.2.4.RELEASE.jar 引入配置文件 Struts的配置文件 web.xml 12345678910&lt;!-- Struts2的核心过滤器 --&gt;&lt;filter&gt;&lt;filter-name&gt;struts2&lt;/filter-name&gt;&lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; struts.xml 1&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt; 123456789101112131415- Hibernate的配置文件 - hibernate.cfg.xml ```xml &lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt; &lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 连接数据库的基本参数 --&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:///ssh1&lt;/property&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;123456&lt;/property&gt; &lt;!-- 配置Hibernate的方言 --&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; truetrueupdate org.hibernate.connection.C3P0ConnectionProvider520120 3000 12345678 - 映射文件- Spring的配置文件 - web.xml ```xml &lt;!-- Spring的核心监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; contextConfigLocation classpath:applicationContext.xml 123456789101112131415161718192021222324252627282930313233343536373839404142 - applicationContext.xml - 日志记录### 将Hibernate的配置交给Spring管理```xml&lt;!-- 引入外部属性文件=============================== --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!-- 配置C3P0连接池=============================== --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driverClass}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;/bean&gt; &lt;!-- Spring整合Hibernate --&gt; &lt;!-- 引入Hibernate的配置的信息=============== --&gt; &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt; &lt;!-- 注入连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 配置Hibernate的相关属性 --&gt; &lt;property name=&quot;hibernateProperties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt; &lt;prop key=&quot;hibernate.show_sql&quot;&gt;true&lt;/prop&gt; &lt;prop key=&quot;hibernate.format_sql&quot;&gt;true&lt;/prop&gt; &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- 设置映射文件 --&gt; &lt;property name=&quot;mappingResources&quot;&gt; &lt;list&gt; &lt;value&gt;com/itheima/ssh/domain/Customer.hbm.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;","link":"/2019/04/14/Spring的学习（一）/"}],"tags":[{"name":"Centos","slug":"Centos","link":"/tags/Centos/"},{"name":"Pig","slug":"Pig","link":"/tags/Pig/"},{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"},{"name":"XML","slug":"XML","link":"/tags/XML/"},{"name":"Tomcat","slug":"Tomcat","link":"/tags/Tomcat/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"}],"categories":[{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Bigdata","slug":"Bigdata","link":"/categories/Bigdata/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Java","slug":"Java","link":"/categories/Java/"}]}