[{"title":"Virtualenv虚拟环境","url":"/2019/04/20/Virtualenv虚拟环境/","content":"\n## virtualenv\n### 下载virtualenv\n```pip install virualenv```\n\n### 创建虚拟环境\n```virualenv + 环境名```\n\n-p + python解释器路径可以指定版本创建\n\n### 开启和退出环境\n- 进入到Scripts目录中使用activate开启\n- 使用deactivate退出环境\n\n***\n## virtualenvwrapper\n\n是一个用于管理虚拟环境的，也可以直接下载 (里面包含virtualenv)\n### 下载virtualwrapper\n```pip install virtualenvwrapper-win```\n\n### 创建虚拟环境\n```mkvirtualenv 环境名```\n\n当虚拟环境创建完成后默认自动进入到虚拟环境\n### 切换虚拟环境或进入到虚拟环境\n```workon + 虚拟环境名```\n\n### 列出、删除、退出或进入到虚拟环境所在目录\n```lsvirtualenv``` -- 列出虚拟环境\n\n```rmvirtualenv``` -- 删除虚拟环境\n\n```deactivate``` -- 退出当前虚拟环境\n\n```cdvirtualenv``` -- 进入到虚拟环境所在目录\n\n### 修改虚拟环境创建时所在目录\n需要在环境变量中添加WORKON_HOME=xxx\n\n==如果需要在创建环境时指定python版本可以添加--python=路径\n            这个参数==\n","categories":["Python"]},{"title":"Python创建单例模式的三种方法","url":"/2019/04/20/Python创建单例模式的三种方法/","content":"\n方法一：使用装饰器\n装饰器维护一个字典对象instances，缓存了所有的单例类，只要单例类不存在则创建，已经创建直接返回该实例对象。\ndef singleton(cls):\n\tinstances = {}\n\n\tdef wrapper(*args, **kwargs):\n\t\tif cls not in instances:\n\t\t\tinstances[cls] = cls(*args, **kwargs)\n\t\treturn instances[cls]\n\treturn wrapper\n\n@singleton\nclass Foo(object):\n\tpass\n\nfoo1 = Foo()\nfoo2 = Foo()\n\nprint(id(foo1), id(foo2))\n\n方法二：使用基类\n__new__是真正创建实例对象的方法，所以重写基类的__new__方法，以此来保证创建对象的时候只生成一个实例。\nclass Singleton(object):\n\tdef __new__(cls, *args, **kwargs):\n\t\tif not hasattr(cls, '_instance'):\n\t\t\tcls._instance = super(Singleton, cls).__new__(cls, *args, **kwargs)\n\t\treturn cls._instance\n\n\nclass Foo(Singleton):\n\tpass\n\nfoo1 = Foo()\nfoo2 = Foo()\n\nprint(foo1 is foo2)\n\n方法三：使用元类\n元类是用于创建类对象的类， 类对象创建实例对象时一定会调用__call__方法，因此在调用__call__时候保证始终只创建一个实例即可，type是Python中的一个元类。\nclass Singleton(type):\n\tdef __call__(cls, *args, **kwargs):\n\t\tif not hasattr(cls, '_instance'):\n\t\t\tcls._instance = super(Singleton, cls).__call__(*args, **kwargs)\n\t\treturn cls._instance\n\n\nclass Foo(object):\n\t__metaclass__ = Singleton\n\nfoo1 = Foo()\nfoo2 = Foo()\n\nprint(foo1 is foo2)\n","tags":["设计模式"],"categories":["Python"]},{"title":"Centos7安装数据库","url":"/2019/04/20/Centos7安装数据库/","content":"\n## MySQL\n\n1. 下载源安装包\n\n`wget http://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm`\n\n2. 安装源\n\n`yum -y install mysql57-community-release-el7-11.noarch.rpm`\n\n3. 安装MySQL服务器\n\n`yum install mysql-community-server`\n\n4. 启动并设置开机自启\n\n`systemctl start  mysqld.service`\n\n`systemctl enable mysqld.service`\n\n5. 初始化数据库密码\n\n`grep \"password\" /var/log/mysqld.log`\n\n#修改默认密码策略\n\n`set global validate_password_policy=0;`    \n\n`set global validate_password_length=1;`\n\n`set password = password('123456');` #设置密码\n\n6. 数据库授权\n\n`mysql>GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;`\n\n## Redis\n\n1. 下载安装包\n\n`wget http://download.redis.io/releases/redis-4.0.6.tar.gz`\n\n2. 解压Redis\n\n`mkidr /usr/local/redis`\n\n`tar -zxvf redis-4.0.6.tar.gz -C /usr/local/redis/`\n\n3. 安装gcc依赖\n\n`yum install gcc`\n\n4. 编译安装\n\n`cd /usr/local/redis/redis-4.0.6`\n\n`make MALLOC=libc`\n\n`cd src && make install`\n","tags":["Centos"],"categories":["Linux"]},{"title":"Pig简单了解","url":"/2019/04/20/Pig简单了解/","content":"\n## 定义\nApache Pig是MapReduce的一个抽象，是一个工具/平台，用于分析较大的数据集，并将它们表示为数据流。\n\n可以使用Pig在Hadoop中执行所有的数据处理的操作\n\n下载地址：[ http://mirrors.shu.edu.cn/apache/pig/pig-0.17.0/ ]\n\n* 先决条件：在运行在Apache Pig之前，必须在系统上安装h好Hadooph和Java\n\n## 安装\n\n``` shell\n\n# 创建pig存放目录\nmkdir /opt/pig\n\n# 解压pig\ntar xvf tar xvf pig-0.17.0.tar.gz\nmv pig-0.17.0/*  /opt/pig\n\n# 添加环境变量\nexport PIG_HOME=/opt/pig\nexport PIG_CLASSPATH=$PIG_HOME/conf\nexport PATH=$PIG_HOME/bin:$PATH\n\n# 查看是否配置成功\npig -version\n```\n\n## Pig的执行模式和机制\n### 模式\n\n- Local模式(pig -x local)\n\t- 在此模式下，所有文件都从本地主机和本地文件系统加载，通常用于测试。\n\n\n- MapReduce模式(pig -x mapreduce)\n\t- 使用Pig加载或处理Hadoop文件系统中存在的数据的地方。在这种模式下， 每当执行Pig语句来处理数据时，会在后端调用一个MapReduce作业。\n\n### 执行机制\n\n**通过三种方式执行，即交互模式**\n\n- 交互模式（Grunt shell）\n\t- 在此shell中，可以输入Pig Latin语句并获取输出（使用Dump运算符）\n\n- 批处理模式（脚本）\n\t- 可以将Pig Latin脚本写入具有.pig扩展名的单个文件中，以批处理模式运行\n\n- 嵌入式模式（UDF）\n\t- Pig允许在Java等编程语言中定义自己的函数，并在脚本中运行\n\n### Pig Grunt Shell\n\n\n示例：`sh ls`\n调用Linux shell 的ls命令\n\n示例： `fs -ls`\n调用HDFS的ls命令\n\n示例： `exec /sample_script.pig`\n从Grunt shell执行Pig脚本\n\n示例： `run /sample_script.pig`\n从Grunt shell运行Pig脚本\n\n**exec和run命令之间的区别是，如果使用run，则脚本中的语句在historym命令中可用**\n\n## Pig Latin\n\nPig Latin适用于使用Pig分析Hadoop中数据的语言\n\n### 数据模型\n\nPig的数据模型是完全嵌套的。\n- 包是元组的集合\n- 元组是有序的字段集\n- 字段是一段数据\n\n### 类型结构运算符\n()\t->\t元组构造函数运算符，用于构建元组\n\n{}\t->\t包构造函数运算符，用于构造包\t->\t示例:{（Raju,30）,（Mohammad,45）}\n\n[]\t->\t映射构造函数运算符，用于构造一个映射\t->\t示例：[name＃Raja,age＃30]\n\n#### 关系运算符\n\n|运算符 | 描述|\n| --- | --- |\n| 加载和存储 |\n| LOAD | 将数据从文件系统(local/HDFS)加载到关系中 |\n| |\n| STORE | 将数据从文件系统(local/HDFS)存储到关系中 |\n| |\n| 过滤 |\n| FILTER | 从关系中删除不需要的行 |\n| |\n| DISTINCT | 从关系中删除重复行 |\n| |\n| FOREACH, GENERATE | 基于数据列生成数据转换 |\n| |\n| STREAM | 使用外部程序转换关系 |\n| |\n| 分组和连接 |\n| JOIN | 连接两个或多个关系 |\n| |\n| COGROUP | 将数据分组为两个或多个关系 |\n| |\n| GROUP | 在单个关系中对数据进行分组 |\n| |\n| CROSS | 创建两个或多个关系的向量积 |\n| |\n| 排序 |\n|ORDER| 基于一个或多个字段（升序或降序）排列关系 |\n| |\n| LIMIT | 从关系中获取有限数量的元组 |\n| |\n| 诊断运算符 |\n| DUMP | 在控制台打印关系的内容 |\n\n\n### LOAD 运算符\n语法： load语句由两部分组成，用“=”运算符分隔。\n\n左侧是想要存储数据的关系的名称\n\n右侧是需要定义如何存储数据\n\n`Relation_name = LOAD 'Input file path' USING function as schema;`\n\n- releation_name：必须要提到要存储的关系\n- Input file path：必须提到存储文件的HDFS目录(MapReduce模式)\n- function：必须从Pig提供的一组加载函数中选择一个函数(BigStorage, JsonLoader, PigStorage, TextLoader)\n- schema：必须定义数据的模式\n\n**PigStorage() 函数，将数据加载并存储为结构化文本文件。它采用分隔符，使用元组的每个实体作为参数分隔。默认情况下，它以“\\t\"作为参数。**\n\n### STORE 存储数据\n语法：`STORE Relation_name INTO 'required_directory_path' [USING function];`\n\n\n### Group运算符\n\n用于在一个或多个关系中对数据进行分组，它收集具有相同key的数据\n\n语法：`Group_data = GROUP Relation_name BY age;`\n\n### Foreach运算符\n\n用于基于列数据生成指定的数据转换\n\n语法：`Relation_name2 = FOREACH Relation_name1 GENRATE (required data);`\n","tags":["Pig"],"categories":["Bigdata"]},{"title":"Spring的学习（一）","url":"/2019/04/14/Spring的学习（一）/","content":"\n## Spring概述\n\n### 什么是Spring\n\nSpring是一个开源框架，Spring是于2003年兴起的一个轻量级的Java开发框架，由Rod Johnson创建。\n\n简单来说，Spring是一个分层的JavaSE/EE full-stack(一站式)轻量级开原框架\n\n- Spring叫做SE/EE开发的一站式框架\n\t- 一站式框架：有EE开发的每一层解决方案\n\t\t- WEB层：SpringMVC\n\t\t- Service层：Spring的Bean管理，Spring声明式事务\n\t\t- DAO层：Spring的JDBC模板，Spring的ORM模块\n\n**特点**\n1. 方便解耦，简化开发\n\n通过Spring提供的IoC容器，我们可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。有了Spring，用户不必再为单实例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。\n\n2. AOP编程的支持\n\n通过Spring提供的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。\n\n3. 声明式事务的支持\n\n在Spring中，我们可以从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。\n\n4. 方便程序的测试\n\n可以用非容器依赖的编程方式进行几乎所有的测试工作，在Spring里，测试不再是昂贵的操作，而是随手可做的事情。例如：Spring对Junit4支持，可以通过注解方便的测试Spring程序。\n\n5. 方便集成各种优秀框架\n\nSpring不排斥各种优秀的开源框架，相反，Spring可以降低各种框架的使用难度，Spring提供了对各种优秀框架（如Struts,Hibernate、Hessian、Quartz）等的直接支持。\n\n6.降低Java EE API的使用难度\n\nSpring对很多难用的Java EE API（如JDBC，JavaMail，远程调用等）提供了一个薄薄的封装层，通过Spring的简易封装，这些Java EE API的使用难度大为降低。\n\n7. Java 源码是经典学习范例\n\nSpring的源码设计精妙、结构清晰、匠心独运，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。Spring框架源码无疑是Java技术的最佳实践范例。如果想在短时间内迅速提高自己的Java技术水平和应用开发水平，学习和研究Spring源码将会使你收到意想不到的效果。\n\n![img](/img/SpringFrameworkRuntime.png)\n\n## SpringIOC(XML)\n\n### 什么是IOC\n\n控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。\n\n- IOC：Inversion of Control(控制反转)\n\t- 控制反转：将对象的创建权反转给（交给）Spring。\n\n```xml\n\n<!-- applicationContext.xml -->\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <bean id=\"foo\" class=\"x.y.Foo\">\n        <meta key=\"cacheName\" value=\"foo\"/>\n        <property name=\"name\" value=\"Rick\"/>\n    </bean>\n\n</beans>\n\n```\n\nSpring方式的调用\n```Java\n\npublic void demo02(){\n    // 创建Spring的工厂\n    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\tObject userDao = applicationContext.getBean(\"userDao\");\n\tuserDao.save();\n}\n\n```\n\n### IOC和DI\n\n- IOC：控制反转，将对象的创建权反转给了Spring\n- DI：依赖注入：前提必须要有IOC的环境（对象已经交给Spring），Spring在管理类的时候会将类的依赖的属性注入（设置）进来\n\n### Spring的工厂类\n\n**结构图**\n\n![img](/img/Spring工厂类的结构图.png)\n\n- BeanFactory：老版本的工厂类\n\t- 调用getBean的时候，才会生成类的实例\n- ApplicationContext：新版本的工厂类\n\t- 加载配置文件的时候，就会将Spring管理的类都实例化\n\t- 有两个实现类\n\t\t- ClassPathXmlApplicationContext：加载类路径下的配置文件\n\t\t- FileSystemXmlApplicationContext ：加载文件系统下的配置文件\n\n## Spring的Bean管理\n\n### <bean>标签的id和name的配置\n\n- id：使用了约束的唯一约束，里面不能出现特殊字符\n- name：没有使用约束中的唯一约束\n\n### Bean生命周期的配置\n\n```xml\n\n<!-- applicationContext.xml -->\n\n<bean id=\"customeDao\" class=\"com.xx.spring.demo02.CustomeDaoImpl\" init-method=\"setup\" destroy-method=\"destroy\"></bean>\n\n```\n\n- init-method：Bean被初始化的时候执行的方法\n- destroy-method：Bean被销毁的时候执行的方法（默认Bean是单例模式，工厂关闭）\n\n### Bean的作用范围的配置\n\n- scope：Bean的作用范围\n\t- singleton：默认，Spring会采用单例模式创建对象\n\t- prototype：多例模式（在Struts2和Spring整合一定会用到）\n\t- request：应用在web项目中，Spring创建这个类以后，会将这个类存入到request范围中\n\t- session：应用在web项目中，Spring创建这个类以后，会将这个类存入到session范围中\n\t- globalsession：必须在porlet环境下使用（在一个地方存入了数据以后，在子系统中就不需要进行登陆）\n\n\n```xml\n\n<!-- applicationContext.xml -->\n\n<bean id=\"customeDao\" class=\"com.xx.spring.demo02.CustomeDaoImpl\" scope=\"xx\"></bean>\n\n```\n\n## Spring属性注入\n\n### 构造方法的属性注入\n\n```Java\n\n// Car.jar\n\npublic Class Car {\n    private String name;\n    private Double price;\n\n    public Car(String name, Double price) {\n        super();\n        this.name = name;\n        this.price = price;\n    }\n}\n\n// SpringDemo01\n\npublic class SpringDemo01 {\n\n\tpublic void demo01() {\n\t\tApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\t\tCar car = applicationContext.getBean(\"car\");\n\t\tSystem.out.println(car);\n\t}\n}\n\n```\n```xml\n\n<!-- applicationContext.xml -->\n\n<bean id=\"car\" class=\"com.xx.spring.demo02.Carl\">\n\t<constructor-arg name=\"name\" value=\"可乐\" />\n\t<constructor-arg name=\"price\" value=\"2.5\">\n</bean>\n\n```\n\n\n### Set方法的属性注入\n\n```xml\n// 和构造方法差不多，配置文件不一样\n<bean id=\"foo\" class=\"x.y.Foo\">\n\t<!-- value：用来设置普通类型的值  ref：设置其他类型的id或name -->\n    <property name=\"name\" value=\"可乐\"/>\n\t<property name=\"price\" value=\"2.5\"/>\n\t<property name=\"car2\" ref=\"car2\"/>\n</bean>\n\n```\n\n### P 名称空间的属性注入\n\n- 写法\n\t- 普通属性：p：属性名=“值”\n\t- 对象属性：p：属性名-ref=”值“\n```xml\nxmlns:p=\"http://www.springframework.org/schema/p\"\n\n<bean id=\"foo\" class=\"x.y.Foo\" p:name=\"可乐\" p:price=\"2.5\" ></bean>\n```\n\n### SpEL的属性注入\n\n- SpEL：Spring Expression Language，Spring的表达语言\n\n### 集合类型的属性注入\n\n```xml\n<!-- Spring的集合属性的注入============================ -->\n\t<!-- 注入数组类型 -->\n\t<bean id=\"collectionBean\" class=\"com.itheima.spring.demo5.CollectionBean\">\n\t\t<!-- 数组类型 -->\n\t\t<property name=\"arrs\">\n\t\t\t<list>\n\t\t\t\t<value>王东</value>\n\t\t\t\t<value>赵洪</value>\n\t\t\t\t<value>李冠希</value>\n\t\t\t</list>\n\t\t</property>\n\n\t\t<!-- 注入list集合 -->\n\t\t<property name=\"list\">\n\t\t\t<list>\n\t\t\t\t<value>李兵</value>\n\t\t\t\t<value>赵如何</value>\n\t\t\t\t<value>邓凤</value>\n\t\t\t</list>\n\t\t</property>\n\n\t\t<!-- 注入set集合 -->\n\t\t<property name=\"set\">\n\t\t\t<set>\n\t\t\t\t<value>aaa</value>\n\t\t\t\t<value>bbb</value>\n\t\t\t\t<value>ccc</value>\n\t\t\t</set>\n\t\t</property>\n\n\t\t<!-- 注入Map集合 -->\n\t\t<property name=\"map\">\n\t\t\t<map>\n\t\t\t\t<entry key=\"aaa\" value=\"111\"/>\n\t\t\t\t<entry key=\"bbb\" value=\"222\"/>\n\t\t\t\t<entry key=\"ccc\" value=\"333\"/>\n\t\t\t</map>\n\t\t</property>\n\n```\n\n## SpringIOC注解\n\n开启Spring的组件扫描\n```xml\n<context:component-scan base-package=\"com.itheima.spring.demo1\" />\n```\n\n在类上添加注解\n```Java\n@component(\"userDao\")\npublic class UserDaoImpl implements UserDao {\n    @Override\n    public void save(){\n        System.out.pringln(\"DAO中保存的方法执行了...\");\n    }\n}\n```\n### Component：组件\n\n- 修饰一个类，将这个类交给Spring管理\n- 这个注解有三个衍射注解\n\t- @Controller：web层\n\t- @Service：service层\n\t- @@Repository：dao层\n\n### 属性注入的注解\n\n-  普通属性\n\t- @Value：设置普通属性的值\n- 对象类型属性\n\t- @Autowired：设置对象类型属性的值，是按照类型完成属性注入\n\t\t- 如果想按照名称完成属性注入，必须让@Autowired注解和@Qualifier一起使用\n\t- @Resource：完成对象类型的属性注入，按照名称完成属性注入。   \n\n## Spring的AOP开发(XML)\n\n### 什么是AOP\n\n在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n\n### AOP相关术语\n\n- Joinpoint：连接点，所谓连接点是指那些被拦截的点。\n- Pointcut：切入点，所谓切入点是指要对哪些Joinpoint进行拦截的定义\n- Advice：通知、增强。所谓通知是指拦截到Joinpoint之后所要做的事情就是通知，通知分为前置通知、后置通知、异常通知、最终通知、环绕通知\n- Introduction：引介。引介是一种特殊的通知，在不修改类代码的情况下，Introduction可以在运行期间为类动态的添加一些方法或Field。\n- Target：目标对象。代理的目标对象\n- Weaving：织入，是指把增强应用到目标对象来创建新的代理对象的过程。\n- Proxy：代理，一个类被AOC织入增强后，就产生一个结果代理类\n- Aspect：切面，是切入点和通知（引介）的结合。\n\n```xml\n\n<!-- 配置目标对象；被增强的对象 -->\n<bean id=\"productDao\" class=\"com.itheima.spring.demo3.ProductDaoImpl\" />\n\n<!-- 将切面类交给Spring管理 -->\n<bean id=\"myAspect\" class=\"com.itheima.spring.demo3.MyAspectXMl\" />\n\n<!-- 通过AOP的配置完成对目标类产生代理 -->\n<aop:config>\n\t<!-- 表达式配置哪些类的哪些方法需要进行增强 -->\n\t<aop:pointcut expression=\"execution(* com.itheima.spring.demo3.ProductDaoImpl.save(..))\" id=\"pointcut1\" />\n\t<!-- 配置切面 -->\n\t<aop:aspect>\n\t\t<aop:before method=\"checkPri\" pointcut-ref=\"pointcut1\" />\n\t</aop:aspect>\n</aop:config>\n```\n\n```Java\n\n// SpringDemo03.java\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(\"classpath:applicationContext.xml\")\npublic class SpringDemo03 {\n    @Resource(name=\"productDao\")\n    private ProductDao productDao;\n\n    @Test\n    public void demo1(){\n        productDao.save();\n        productDao.update();\n    }\n}\n\n// MyAspectXML.java  切面类\n\npublic class MyAspectXMl {\n    public void checkPri() {\n        System.out.pringln(\"权限校验=====\");\n    }\n}\n```\n\n### 通知类型\n\n- 前置通知：在目标方法执行之前执行（获得切入点信息）\n- 后置通知：在目标方法执行之后执行（获得方法的返回值）\n- 环绕通知：在目标方法执行前和执行后执行（可以阻止目标方法的执行）\n- 异常抛出通知：在目标方法执行出现异常的时候执行\n- 最终通知：无论目标方法是否出现异常最终通知都会执行\n\n```xml\n<!-- 前置通知 -->\n<aop:before method=\"checkPri\" pointcut-ref=\"pointcut1\" />\n<!-- 后置通知 -->\n<aop:after-returning method=\"writeLog\" pointcut-ref=\"pointcut2\" returning=\"result\" />\n<!-- 环绕通知 --->\n<aop:around method=\"around\" pointcut-ref=\"pointcut3\" />\n<!-- 异常抛出通知 -->\n<aop:after-throwing method=\"afterThrowing\" pointcut-ref=\"pointcut4\" throwing=\"ex\" />\n<!-- 最终通知 -->\n<aop:after method=\"after\" pointcut-ref=\"pointcut4\" />\n```\n\n```Java\npublic class MyAspectXML {\n    // 前置通知\n    public void checkPri(JoinPoint joinPoint) {\n        System.out.println(\"权限校验===\" + joinPoint);\n    }\n\n    // 后置通知\n    public void writeLog(Object result) {\n        System.out.println(\"日志记录===\" + result);\n    }\n\n    // 性能监控，环绕通知\n    public Object around(ProceedingJoinPoint joinPoint) {\n        System.out.println(\"环绕前通知===\");\n        Object obj = joinPoint.proceed();\n        System.out.println(\"环绕后通知===\");\n    \treturn obj;\n    }\n\n    // 异常抛出通知\n    public void afterThrowing(Throwable ex) {\n        System.out.println(\"异常抛出通知===\" + ex.getMessage());\n    }\n\n    // 最终通知，相当于finally代码块的内容\n    public void after() {\n        System.out.println(\"最终通知===\");\n    }\n}\n```\n\n### 切入点表达式语法\n\n- 基于execution的函数完成的\n- 语法\n\t- [访问修饰符] 方法返回值 包名.类名.方法名(参数)\n\t- public void com.itheima.spring.CustomerDao.save(..)\n## Spring的AOP注解\n\n```xml\n<!-- 在配置文件中开启注解AOP -->\n<aop:aspectj-autoproxy  />\n```\n\n```Java\n@Aspect\npublic class MyAspectAnno {\n    @Before(value=\"execution(* com.itheima.spring.demo1.OrderDao.save(..)\")\n    public void before() {\n        System.out.println(\"前置增强===\");\n    }\n}\n```\n\n### 注解的AOP通知类型\n\n- @Before：前置通知\n- @AfterReturning：后置通知\n- @Around：环绕通知\n- @AfterThrowing：异常抛出通知\n- @After：最终通知\n\n```Java\n// 切入点注解\n@Pointcut(value=\"execution(* com.itheima.spring.demo1.OrderDao.find(..))\")\nprivate void pointcut1(){}\n\n@After(value=\"MyAspectAnno.pointcut1()\")\n    public void before() {\n        System.out.println(\"前置增强===\");\n    }\n\n```\n\n## Spring的事务管理\n\n- 事务：逻辑上的一组操作，组成这组操作的各个单元，要么全部成功，要么全部失败。\n- 事务的特性：\n\t- 原子性：事务不可分割\n\t- 一致性：事务执行前后数据完整性保持一致\n\t- 隔离性：一个事务的执行不应该受到其他事务的干扰\n\t- 持久性：一旦事务结束，数据就持久化到数据库\n- 不考虑隔离性引发安全性问题\n\t- 读问题\n\t\t- 脏读：一个事务读到另一个事务未提交的数据\n\t\t- 不可重复读：一个事务读到另一个事务已经提交的update的数据，导致一个事务中多次查询结果不一致\n\t\t- 虚读、幻读：一个事务读到另一个事务已经提交的insert的数据，导致一个事务中多次查询结果不一致\n\t- 写问题\n\t\t- 丢失更新\n\n- 解决读问题\n\t- 设置事务的隔离级别\n\t\t- Read uncommitted：未提交读，任何读问题解决不了。\n\t\t- Read committed：已提交到，解决脏读，但是不可重复读和虚读有可能发生\n\t\t- Repeatable read：重复读，解决脏读和不可重复读，但是虚读有可能发生\n\t\t- Serializable：解决所有读问题。\n\n### Spring的事务管理API\n\n- PlatformTransactionManager：平台事务管理器\n\t- 接口，是Spring用于管理事务的真正的对象\n\t\t- DataSourceTransactionManager：底层使用JDBC管理事务\n\t\t- HibernateTransactionManager：底层使用Hibernate管理事务\n\n- TransactionDefinition：事务定义信息\n\t- 事务定义：用于定义事务的相关的信息，隔离级别、超时信息、传播行为、是否只读。\n\n- TransactionStatus：事务的状态\n\t- 事务状态：用于记录在事务管理过程中，事务的状态的对象。\n\n#### 事务管理的API关系\n\nSpring进行事务管理的时候，首先平台事务管理器根据事务定义信息进行事务的管理，在事务管理过程中，产生各种状态，将这些状态的信息记录到事务状态的对象中。\n\n#### Spring事务的传播行为\n\n用途：如果遇到了特别复杂的业务逻辑，有可能出现业务层之间的方法相互调用。事务的传播行为主要用来解决业务层方法相互调用的问题。\n\n- Spring中提供了七种事务的传播行为\n\t- 保证同一个事务中\n        - PROPAGATION_REQUIRED：支持当前事务，如果不存在，就新建一个（默认）\n        - PROPAGATION_SUPPORTS：支持当前事务，如果不存在，就不使用事务\n        - PROPAGATION_MANDATORY：支持当前事务，如果不存在，抛出异常\n\t- 保证没有在同一个事务中\n\t\t- PROPAGATION_REQUIRES_NEW：如果有事务存在，挂起当前事务，创建一个新的事务\n\t\t- PROPAGATION_NEVER：以非事务方式运行，如果有事务存在，挂起当前事务\n\t\t- PROPAGATION_NESTED：如果当前事务存在，则嵌套事务执行\n\n### 编程式事务\n\n```xml\n<!-- 配置平台事务管理器 -->\n<bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t<property name=\"dataSource\" ref=\"dataSource\" />\n</bean>\n\n<!-- 配置事务管理的模板 -->\n<bean id=\"transactionTemplate\" class=\"org.springframework.transaction.support.TransactionTemplate\">\n\t<property name=\"transactionManager\" ref=\"transactionManager\" />\n</bean>\n\n<!-- 注入事务管理的模板 -->\n<property name=\"trsactionTemplate\" ref=\"transactionTemplate\" />\n```\n\n```Java\n// 注入事务管理的模板\nprivate TransactionTemplate trsactionTemplate;\npublic void setTrsactionTemplate(TransactionTemplate trsactionTemplate) {\n    this.trsactionTemplate = trsactionTemplate;\n}\n\npublic void transfer(final String from, final String to, final Double money) {\n    trsactionTemplate.execute(new TransactionCallbackWithoutResult() {\n        @Override\n        protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {\n            accountDao.outMoney(from, money);\n            // int d = 1/0;\n            accountDa.inMoney(to, money);\n        }\n    });\n}\n```\n\n### 声明式事务管理\n\n#### XML方式的声明式事务管理\n```xml\n<!-- 配置事务管理器 -->\n<bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t<property name=\"dataSource\" ref=dataSource\"\"/>\n</bean>\n\n<!-- 配置事务的增强 -->\n<tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n\t<tx:attributes>\n\t\t<tx:method name=\"save*\" propagation=\"REQUIRED\" />\n\t</tx:attributes>\n<tx:advice>\n\n<!-- AOP的配置 -->\n<aop:config>\n\t<aop:pointcut expression=\"execution(* com.itheima.tx.demo2.AccountServiceImpl.*(..))\"  id=\"pointcut1\" />\n\t<aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pointcut1\" />\n</aop:config>\n```\n#### 注解方式的声明式事务管理\n\n```xml\n<!-- 配置事务管理器 -->\n<bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t<property name=\"dataSource\" ref=dataSource\"\"/>\n</bean>\n\n<!-- 开启注解事务 -->\n<tx:annotation-driven transaction-manager=\"transactionManager\" />\n```\n```Java\n// 在业务层上添加注解\n@Transactional\npublic class AccountServiceImpl implements AccountService{}\n\n```\n\n## JdbcTemplate\n\n### 使用JDBC的模板：保存数据\n\n```Java\npublic class JdbcDemo1 {\n    @Test\n    public void demo1() {\n        // 创建连接池\n        DriverManagerDataSource dataSource = new DriverManagerDataSource();\n        dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");\n        dataSource.setUrl(\"jdbc:mysql:///spring4_day03\");\n        dataSource.setUsername(\"root\");\n        dataSource.setPassword(\"abc\");\n\n        // 创建jdbc模板\n        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n        jdbcTemplate.update(\"insert into account values (null,?,?)\", \"xx\", 1000d);\n    }\n}\n```\n\n### 将连接池和模板交给Spring管理\n\n```xml\n\n<!-- 配置Spring的内置连接池 -->\n<bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n\t<!-- 属性注入 -->\n\t<property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" />\n\t<property name=\"url\" value=\"jdbc:mysql:///spring4_day03\" />\n\t<property name=\"username\" value=\"root\" />\n\t<property name=\"password\" value=\"abc\" />\n</bean>\n\n<!-- 配置Spring的JDBC的模板 -->\n<bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\" />\n\t<property name=\"dataSource\" ref=\"dataSource\" />\n</bean>\n```\n```Java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(\"classpath:applicationContext.xml\")\npublic class JdbcDemo2 {\n\n\t@Resource(name=\"jdbcTemplate\")\n\tprivate JdbcTemplate jdbcTemplate;\n\n    @Test\n    public void demo2() {\n        jdbcTemplate.update(\"insert into account values (null, ?, ?)\", \"xx\", 1000d);\n    }\n}\n```\n\n### 使用开源的数据库连接池\n\n#### DBCP的使用\n```xml\n<!-- 配置DBCP连接池 -->\n<bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\">\n\t<property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" />\n\t<property name=\"url\" value=\"jdbc:mysql:///spring4_day03\" />\n\t<property name=\"username\" value=\"root\" />\n\t<property name=\"password\" value=\"abc\" />\n</bean>\n```\n\n#### C3P0的使用\n\n```xml\n<!-- 配置C3P0连接池 -->\n<bean id=\"dataSource\" class=\"org.mchange.v2.c3p0.ComboPooledDataSource\">\n\t<property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\" />\n\t<property name=\"jdbcUrl\" value=\"jdbc:mysql:///spring4_day03\" />\n\t<property name=\"user\" value=\"root\" />\n\t<property name=\"password\" value=\"abc\" />\n</bean>\n```\n\n### 引入外部属性文件\n```xml\n# jdbc.properties\njdbc.driverClass=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql:///spring4_day03\njdbc.username=root\njdbc.password=abc\n\n\n<!-- 引入属性文件 -->\n<!-- 第一种方式通过一个bean标签引入（很少使用） -->\n<bean class=\"org.springframework.beans.factory.config.PropertyPlanceholderConfigurer\">\n\t<property name=\"location\" value=\"classpath:jdbc.properties\" />\n</bean>\n\n<!-- 第二种方式通过context的标签引入 -->\n<context:property-placeholder localtion=\"classpath:jdbc.properties\" />\n\n<!-- 配置连接池的时候 -->\n<property name=\"driverClass\" value=\"${jdbc.driverClass}\" />\n<property name=\"jdbcUrl\" value=\"${jdbc.url}\" />\n\n```\n\n\n## SSH整合\n![img](/img/SSH整合回顾.png)\n\n### 无障碍整合\n\n- 创建Web项目，引入jar包\n\t- Struts2的jar包\n\t\t- struts-2.3.24\\apps\\struts2-blank\\WEB-INF\\lib\\*.jar\n\t\t- asm-3.3.jar\n\t\t- asm-commons-3.3.jar\n\t\t- asm-tree-3.3.jar\n\t\t- commons-fileupload-1.3.1.jar\n\t\t- commons-io-2.2.jar\n\t\t- commons-lang3-3.2.jar\n\t\t- freemarker-2.3.22.jar\n\t\t- javassist-3.11.0.GA.jar\n\t\t- log4j-api-2.2.jar\n\t\t- log4j-core-2.2.jar\n\t\t- ognl-3.0.6.jar\n\t\t- struts2-core-2.3.24.jar\n\t\t- xwork-core-2.3.24.jar\n\t\t- struts2-convention-plugin-2.3.24.jar\t----Struts2的注解开发包\n\t\t- struts2-json-plugin-2.3.24.jar\t----Struts2的整合AJAX的开发包\n\t\t- struts2-spring-plugin-2.3.24.jar\t----Struts2的整合Spring的开发包\n\t- Hibernate的jar包\n\t\t- Hibermate的开发必须包（Struts2和Hibernate都引入了一个相同的jar包，javassist，需要删除一个）\n\t\t- hibernate-release-5.0.7.Final\\lib\\required\\*.jar\n\t\t- antlr-2.7.7.jar\n\t\t- dom4j-1.6.1.jar\n\t\t- geronimo-jta_1.1_spec-1.1.1jar\n\t\t- hibernate-commons-annotations-5.0\n\t\t- hibernate-core-5.0.7.Final.jar\n\t\t- hibernate-jpa-2.1-api-1.0.0.Final.jar\n\t\t- jandex-2.0.0.Final.jar\n\t\t- javassist-3.18.1-GA.jar\n\t\t- jboss-logging-3.3.0.Final.jar\n        - MYSQL驱动\n        - 日志记录\n        \t- log4j-1.2.16.jar\n        \t- slf4j-api-1.6.1.jar\n        \t- slf4j-log4j12-1.7.2.jar\n\t- Spring的jar包\n\t\t- IOC的开发\n\t\t\t- com.springsource.org.apache.commons.loggin-1.1.1.jar\n\t\t\t- com.springsource.org.apache.log4j-1.2.15.jar\n\t\t\t- spring-beans-4.2.4.RELEASE.jar\n\t\t\t- spring-context-4.2.4.RELEASE.jar\n\t\t\t- spring-core-4.2.4.RELEASE.jar\n\t\t\t- spring-expression-4.2.4.RELEASE.jar\n\t\t- AOP的开发\n\t\t\t- com.springsource.org.aopalliance-1.0.0.jar\n\t\t\t- com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar\n\t\t\t- spring-aop-4.2.4.RELEASE.jar\n\t\t\t- spring-aspects-4.2.4.RELEASE.jar\n\t\t- JDBC模板的开发\n\t\t\t- spring-jdbc-4.2.4.RELEASE.jar\n\t\t\t- spring-tx-4.2.4.RELEASE.jar （如果只用事务管理只用这个）\n\t\t- 整合web项目的开发\n\t\t\t- spring-web-4.2.4.RELEASE.jar\n\t\t- 整合单元测试的开发\n\t\t\t- spring-test-4.2.4.RELEASE.jar\n\t\t- 整合hibernate的开发\n\t\t\t- spring-orm-4.2.4.RELEASE.jar\n\n- 引入配置文件\n  - Struts的配置文件\n    - web.xml\n      ```xml\n      <!-- Struts2的核心过滤器 -->\n      <filter>\n      <filter-name>struts2</filter-name>\n      <filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>\n      </filter>\n\n        <filter-mapping>\n        <filter-name>struts2</filter-name>\n        <url-pattern>/*</url-pattern>\n        </filter-mapping>\n      ```\n    - struts.xml\n        ```xml\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        ```\n    <!DOCTYPE struts PUBLIC\n        \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\"\n        \"http://struts.apache.org/dtds/struts-2.3.dtd\">\n    <struts>\n        <!-- 配置Struts2的常量 -->\n        <constant name=\"struts.action.extension\" value=\"action\"/>\n    </struts>\n\n        ```\n  - Hibernate的配置文件\n    - hibernate.cfg.xml\n      ```xml\n        <!DOCTYPE hibernate-configuration PUBLIC\n      \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n      \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\">\n      <hibernate-configuration>\n      <session-factory>\n      <!-- 连接数据库的基本参数 -->\n      <property name=\"hibernate.connection.driver_class\">com.mysql.jdbc.Driver</property>\n      <property name=\"hibernate.connection.url\">jdbc:mysql:///ssh1</property>\n      <property name=\"hibernate.connection.username\">root</property>\n      <property name=\"hibernate.connection.password\">123456</property>\n      <!-- 配置Hibernate的方言 -->\n      <property name=\"hibernate.dialect\">org.hibernate.dialect.MySQLDialect</property>\n      ```\n\n    <!-- 可选配置================ -->\n    <!-- 打印SQL -->\n    <property name=\"hibernate.show_sql\">true</property>\n    <!-- 格式化SQL -->\n    <property name=\"hibernate.format_sql\">true</property>\n    <!-- 自动创建表 -->\n    <property name=\"hibernate.hbm2ddl.auto\">update</property>\n\n    <!-- 配置C3P0连接池 -->\n    <property name=\"connection.provider_class\">org.hibernate.connection.C3P0ConnectionProvider</property>\n    <!--在连接池中可用的数据库连接的最少数目 -->\n    <property name=\"c3p0.min_size\">5</property>\n    <!--在连接池中所有数据库连接的最大数目  -->\n    <property name=\"c3p0.max_size\">20</property>\n    <!--设定数据库连接的过期时间,以秒为单位,\n    如果连接池中的某个数据库连接处于空闲状态的时间超过了timeout时间,就会从连接池中清除 -->\n    <property name=\"c3p0.timeout\">120</property>\n     <!--每3000秒检查所有连接池中的空闲连接 以秒为单位-->\n    <property name=\"c3p0.idle_test_period\">3000</property>\n\n    <!-- 引入映射 -->\n\n\n  </session-factory>\n  </hibernate-configuration>\n        ```\n  \t- 映射文件\n  - Spring的配置文件\n   - web.xml\n        ```xml\n          \t  <!-- Spring的核心监听器 -->\n          <listener>\n          \t<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n          </listener>\n        ```\n\n  <!-- 加载Spring配置文件的路径，默认加载的是WEB-INF/applicationContext.xml -->\n  <context-param>\n  \t<param-name>contextConfigLocation</param-name>\n  \t<param-value>classpath:applicationContext.xml</param-value>\n  </context-param>\n  \t```\n  \t- applicationContext.xml\n  \t- 日志记录\n\n\n\n### 将Hibernate的配置交给Spring管理\n\n```xml\n\n<!-- 引入外部属性文件=============================== -->\n\t<context:property-placeholder location=\"classpath:jdbc.properties\"/>\n\n\t<!-- 配置C3P0连接池=============================== -->\n\t<bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n\t\t<property name=\"driverClass\" value=\"${jdbc.driverClass}\"/>\n\t\t<property name=\"jdbcUrl\" value=\"${jdbc.url}\"/>\n\t\t<property name=\"user\" value=\"${jdbc.username}\"/>\n\t\t<property name=\"password\" value=\"${jdbc.password}\"/>\n\t</bean>\n\n\t<!-- Spring整合Hibernate -->\n\t<!-- 引入Hibernate的配置的信息=============== -->\n\t<bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\">\n\t\t<!-- 注入连接池 -->\n\t\t<property name=\"dataSource\" ref=\"dataSource\"/>\n\t\t<!-- 配置Hibernate的相关属性 -->\n\t\t<property name=\"hibernateProperties\">\n\t\t\t<props>\n\t\t\t\t<prop key=\"hibernate.dialect\">org.hibernate.dialect.MySQLDialect</prop>\n\t\t\t\t<prop key=\"hibernate.show_sql\">true</prop>\n\t\t\t\t<prop key=\"hibernate.format_sql\">true</prop>\n\t\t\t\t<prop key=\"hibernate.hbm2ddl.auto\">update</prop>\n\t\t\t</props>\n\t\t</property>\n\n\t\t<!-- 设置映射文件 -->\n\t\t<property name=\"mappingResources\">\n\t\t\t<list>\n\t\t\t\t<value>com/itheima/ssh/domain/Customer.hbm.xml</value>\n\t\t\t</list>\n\t\t</property>\n\t</bean>\n\n```\n","tags":["Spring"],"categories":["Java"]},{"title":"XML & Tomcat","url":"/2019/03/28/XML&Tomcat/","content":"\n##  XML & Tomcat\n\n> 被设计用来传输和存储数据\n\n### 查看XML文件\nXMl文件中包含了许多的元素，XML格式的信息和其它标记的基本单元，以及各种各样的数据。\n\n在所有的主流的浏览器中，均能够查看原始的XML文件\n\n###  什么是XML\n- 指可扩展标记语言（EXtendsible Markup Language）\n- 是一种很像HTML的标记语言\n- 设计宗旨是传输数据，而不是显示数据\n- 标签没有被预定义，需要自行定义\n- 被设计为具有自我描述性\n\n### 和HTML的差异\n- XML是被设计用来传输和存储数据，其焦点是数据的内容\n- HTML被设计用来显示数据，其焦点是数据的外观\n> XML用于传输数据，而HTML用于格式化并显示数据\n\n### 定义XML\n1. 文档声明\nversion：解析这个xml的时候，使用什么版本的解析器解析\nencoding：解析xml中的文字的时候，使用什么编码来翻译\n\tstandalone：no - 该文档会依赖关联其它文档\tyes - 这是一个独立的文档\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n\n2. 使用CSS来格式化XML文档\n\n<?xml-stylesheet type=\"text/css\" href=\"cd_catalog.css\"?>\n使用CSS格式化XML不是常用的方法\n\n3. 使用XSLT显示XML\n\n通过使用XSLT，可以把XMl文档转换HTML格式\n> XSLT是首选的XML样式表语言\t(eXtensible Stylesheet Language Transformations)\n\n### XML命名规则\n- 名称可以包含字母、数字以及其它的字符\n- 名称不能以数字或者标点符号开始\n- 名称不能以字母xml（或者XML、Xml等等）开始\n- 名称不能包含空格\n\n### XML DTD（Document Type Definition）文档类型定义\n- 拥有正确语法的XMl被称为“形式良好”的XMl\n\t- 文档必须有一个根元素\n\t- 元素都必须有一个关闭标签\n\t- 标签对大小写敏感\n\t- 元素必须被正确的嵌套\n\t- 属性值必须加双引号\n\n> DTD的作用\n- DTD是一种保证XML文档格式正确的有效方法，可以通过比较XML文档和DTD文件来看文档是否符合规范，元素和标签使用是否正确\n- XML文件提供应用程序一个数据交换的格式，DTD正是让XML能够成为数据交换的标准。\n- DTD文件是一个ASCII的文本文件，后缀名为.dtd\n\n通过引入的方式：\n```dtd\n文档类型   根标签名字   网络上的dtd    dtd的路径\n<!DOCTYPE stus PUBLIC \"//UNKNOWN/\" \"unknown.dtd\">\n\n本地的为\n<!DOCTYPE stus SYSTEM \"stus.dtd\">\n```\n\n直接在XML里面嵌入DTD的约束规则：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<!DOCTYPE stus [\n    <!ELEMENT stus (stu)>\n    <!ELEMENT stu (name,age,address)>\n    <!ELEMENT name (#PCDATA)>\n    <!ELEMENT age (#PCDATA)>\n    <!ELEMENT address (#PCDATA)>\n]>\n\n<stus>\n\t<stu>\n\t\t<name>李四</name>\n\t\t<age>12</age>\n\t\t<address>武汉</address>\n\t</stu>\n</stus>\n```\n\n### XML Schema\n约束文档\n```xsd\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!-- xmlns->xml namespace 命名空间\n目标名称空间，下面的那些元素都与这个命名空间绑定上\ntargetNamespace=\"http://www.example.org/teacher\"\n元素的格式化情况\nelementFormDefault=\"qualified\"> -->\n\n\n<schema xmlns=\"http://www.w3.org/2001/XMLSchema\"\n\ttargetNamespace=\"http://www.example.org/teacher\"\n\txmlns:tns=\"http://www.example.org/teacher\"\n\telementFormDefault=\"qualified\">\n\n\t<element name=\"teachers\">\n\t\t<complexType>\n\t\t\t<sequence maxOccurs=\"unbounded\">\n\t\t\t\t<!-- 这是一个复杂元素 -->\n\t\t\t\t<element name=\"teacher\">\n\t\t\t\t\t<!-- 这是用于声明teacher元素是复杂元素 -->\n\t\t\t\t\t<complexType>\n\t\t\t\t\t\t<sequence>\n\t\t\t\t\t\t\t<!-- 以下两个是简单元素 -->\n\t\t\t\t\t\t\t<element name=\"name\" type=\"string\"></element>\n\t\t\t\t\t\t\t<element name=\"age\" type=\"int\"></element>\n\t\t\t\t\t\t</sequence>\n\t\t\t\t\t</complexType>\n\t\t\t\t</element>\n\t\t\t</sequence>\n\t\t</complexType>\n\t</element>\n</schema>\n```\n\n实例文档\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<!-- xmlns:xsi 必须是这样的写法，也就是这个值固定了 xmlns 这里是命名空间，也固定了，写的是schema里面的顶部目标命名空间\n\txsi:schemaLocation 有两段，前面是命名空间，也就是目标空间的值，后面是约束文档的路径 -->\n\n\n<teachers xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txmlns=\"http://www.w3.org/2001/XMLSchema\"\n\txsi:schemaLocation=\"http://www.w3.org/2001/XMLSchema teacher.xsd\">\n\t<teacher>\n\t\t<name>z</name>\n\t\t<age>12</age>\n\t</teacher>\n\t<teacher>\n\t\t<name>z</name>\n\t\t<age>12</age>\n\t</teacher>\n</teachers>\n```\n\n#### 命名空间的作用\n一个xml如果想指定它的约束规则，假设使用的是DTD，那么这个xml只能指定一个DTD\n\n但是如果一个xml的约束是定义在schema里面，并且是多个schema，那么是可以的。\n\n简单来说：一个xml可以引用多个schema约束，但是只能引用一个DTD约束。\n\n名称空间的作用就是在写元素的时候，可以指定该元素使用的是哪一套约束规则。\n\n默认情况下，如果只有一套规则，那么都可以这么写。\n\n```xml\n\t<name>zhangsan</name>\n\t<aa:name></name>\n\t<bb:name></name>\n```\n\n### XMl解析方式\n> DOM：document object model\n\n把整个xml全部读到内从当中，形成树状结构。\n\n- 整个文档称之为document对象\n- 属性对应Attribute对象\n- 所有的元素节点对应Element对象\n- 文本称之为Text对象\n- 以上所有对象都可称之为Node节点\n\n> SAX：Simple API for Xml\n\n基于事件驱动\n\n不可以进行增删，只能查询\n\n### Dom4j 基本用法\n\nelement.element(\"stu\");\t\t返回该元素下的第一个stu元素\nelement.elements();\t\t返回该元素下的所有子元素\n\n1. 创建SaxReader对象\n2. 指定解析的xml\n3. 获取根元素\n4. 根据根元素获取子元素或者下面的子孙元素\n\n```java\ntry {\n\t\t\t// 1. 创建sax读取对象\n\t\t\tSAXReader reader = new SAXReader();\n\n\t\t\t// 2. 指定解析的xml文件\n\t\t\tDocument document = reader.read(new File(\"src/xml/stus.xml\"));\n\n\t\t\t// 3. 得到元素\n\t\t\tElement rootElement = document.getRootElement();\n\t\t\tString name = rootElement.element(\"stu\").element(\"name\").getStringValue();\n\t\t\t//System.out.println(name);\n\n\t\t\t// 获取根元素下的所有元素\n\t\t\tList<Element> elements = rootElement.elements();\n\t\t\tfor (Element element : elements) {\n\t\t\t\tString value1 = element.getStringValue();\n\t\t\t\tString value2 = element.element(\"name\").getText();\n\t\t\t\tSystem.out.println(value2);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t// TODO: handle exception\n\t\t\te.printStackTrace();\n\t\t}\n```\n\n#### Dom4j的Xpath使用\n1. 添加jar包依赖\t\tjaxen-1.1-beta-6.jar\n2. 在查找指定节点的时候，根据Xpath语法规则来查找\n3. 后续的代码与以前的解析一样\n\n```java\n\t\t\t// 要想使用Xpath，还得添加支持的jar:jaxen\n\t\t\t// 获取的是第一个，只返回一个\n\t\t\tElement nameElement = (Element) rootElement.selectSingleNode(\"//name\");\n\t\t\tSystem.out.println(nameElement.getName());\n\n\n\t\t\t// 获取文档里面的所有name元素\n\t\t\tList<Element> list = rootElement.selectNodes(\"//name\");\n\t\t\tfor (Element element : list) {\n\t\t\t\tSystem.out.println(element.getText());\n\t\t\t}\n```\n\n## Tomcat目录\nbin\n\t包含了一些jar，bat文件\tstartup.bat\n\nconf\n\ttomcat的配置\tserver.xml\tweb.xml\n\nlib\n\ttomcat运行所需的jar文件\n\nlogs\n\t运行的日志文件\n\ntemp\n\t临时文件\n\nwebapps\n\t发布到tomcat服务器上的项目\n\nwork\n\tjsp翻译成class文件存放地\n\n### 配置虚拟路径\n1. 在conf/server.xml\t找到Host元素节点\n2. 加入以下内容\n\n\t<!-- docBase:项目的路径地址\n    path：对应的虚拟路径\t一定要以/开始\n    -->\n    <Context docBase=\"D:\\xml02\" path=\"/a\"></Context>\n\nOR\n\n1. 在tomcat/conf/catalina/localhost/ 文件夹下新建一个xml文件，名字自定义\n2. 在这个文件里面写入\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<Context docBase=\"D:\\xml02\"></Context>\n访问：http://localhost:8080/person/xml名字即可\n","tags":["XML","Tomcat"],"categories":["Java"]},{"title":"Hello World","url":"/2019/03/28/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]